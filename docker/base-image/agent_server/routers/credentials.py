"""
Credential management endpoints.
"""
import os
import logging
from datetime import datetime
from pathlib import Path
from typing import List

from fastapi import APIRouter, HTTPException, Query

from ..models import (
    CredentialUpdateRequest,
    CredentialReadRequest,
    CredentialReadResponse,
    CredentialInjectRequest,
    CredentialInjectResponse,
)
from ..state import agent_state
from ..services.trinity_mcp import inject_trinity_mcp_if_configured

logger = logging.getLogger(__name__)
router = APIRouter()


@router.post("/api/credentials/update")
async def update_credentials(request: CredentialUpdateRequest):
    """
    Update agent credentials by writing .env and regenerating .mcp.json.

    This endpoint is called by the Trinity backend when credentials are updated.
    It writes the new credentials to files that MCP servers read at startup/runtime.

    Flow:
    1. Write credentials to /home/developer/.env
    2. If mcp_config provided, write to /home/developer/.mcp.json
    3. If .mcp.json.template exists, generate .mcp.json from it using envsubst
    """
    home_dir = Path("/home/developer")
    env_file = home_dir / ".env"
    mcp_file = home_dir / ".mcp.json"
    mcp_template = home_dir / ".mcp.json.template"

    updated_files = []

    try:
        # 1. Write .env file
        env_lines = ["# Generated by Trinity - Agent credentials", ""]
        for var_name, value in request.credentials.items():
            # Escape special characters in values
            escaped_value = str(value).replace('"', '\\"')
            env_lines.append(f'{var_name}="{escaped_value}"')

        env_content = "\n".join(env_lines) + "\n"
        env_file.write_text(env_content)
        updated_files.append(str(env_file))
        logger.info(f"Updated .env with {len(request.credentials)} credentials")

        # 2. Handle .mcp.json generation
        if request.mcp_config:
            # If backend provides pre-generated .mcp.json, use it
            mcp_file.write_text(request.mcp_config)
            updated_files.append(str(mcp_file))
            logger.info("Updated .mcp.json from provided config")

            # Re-inject Trinity MCP after updating .mcp.json
            if inject_trinity_mcp_if_configured():
                logger.info("Re-injected Trinity MCP after credential reload")

        elif mcp_template.exists():
            # Generate .mcp.json from template using envsubst-style substitution
            template_content = mcp_template.read_text()

            # Perform variable substitution (${VAR_NAME} -> value)
            generated_content = template_content
            for var_name, value in request.credentials.items():
                placeholder = f"${{{var_name}}}"
                generated_content = generated_content.replace(placeholder, str(value))

            mcp_file.write_text(generated_content)
            updated_files.append(str(mcp_file))
            logger.info("Generated .mcp.json from template")

            # Re-inject Trinity MCP after regenerating .mcp.json
            # This uses the same injection logic as agent startup
            if inject_trinity_mcp_if_configured():
                logger.info("Re-injected Trinity MCP after credential reload")

        # 3. Also export credentials to environment (for current process)
        # Note: This won't affect already-running subprocesses, but helps for new ones
        for var_name, value in request.credentials.items():
            os.environ[var_name] = str(value)

        # 4. Write file-type credentials (e.g., service account JSON files)
        files_written = []
        if request.files:
            for file_path, content in request.files.items():
                try:
                    # Resolve path relative to home directory
                    # Strip leading slash if present to make it relative
                    clean_path = file_path.lstrip("/")
                    target_path = home_dir / clean_path

                    # Create parent directories if needed
                    target_path.parent.mkdir(parents=True, exist_ok=True)

                    # Write the file
                    target_path.write_text(content)

                    # Set restrictive permissions (600 = owner read/write only)
                    target_path.chmod(0o600)

                    files_written.append(str(target_path))
                    logger.info(f"Wrote credential file: {target_path}")
                except Exception as e:
                    logger.error(f"Failed to write credential file {file_path}: {e}")

        return {
            "status": "success",
            "updated_files": updated_files + files_written,
            "credential_count": len(request.credentials),
            "files_written": files_written,
            "note": "MCP servers may need to be restarted to pick up new credentials"
        }

    except Exception as e:
        logger.error(f"Failed to update credentials: {e}")
        raise HTTPException(status_code=500, detail=f"Credential update failed: {str(e)}")


@router.get("/api/credentials/status")
async def get_credentials_status():
    """
    Get current credential status - which files exist and when they were last modified.
    """
    home_dir = Path("/home/developer")
    files_status = {}

    credential_files = [
        ".env",
        ".mcp.json",
        ".mcp.json.template",
        ".credentials.enc"  # New encrypted credentials file
    ]

    for filename in credential_files:
        filepath = home_dir / filename
        if filepath.exists():
            stat = filepath.stat()
            files_status[filename] = {
                "exists": True,
                "size": stat.st_size,
                "modified": datetime.fromtimestamp(stat.st_mtime).isoformat()
            }
        else:
            files_status[filename] = {"exists": False}

    # Count credentials in .env if it exists
    env_file = home_dir / ".env"
    credential_count = 0
    if env_file.exists():
        content = env_file.read_text()
        for line in content.splitlines():
            line = line.strip()
            if line and not line.startswith("#") and "=" in line:
                credential_count += 1

    return {
        "agent_name": agent_state.agent_name,
        "files": files_status,
        "credential_count": credential_count
    }


# ============================================================================
# New Credential Endpoints (CRED-002: Simplified Credential System)
# ============================================================================

@router.get("/api/credentials/read")
async def read_credential_files(paths: str = Query(..., description="Comma-separated list of file paths")):
    """
    Read credential files from workspace.

    Used by the backend to read existing credential files before encrypting.

    Args:
        paths: Comma-separated list of file paths relative to /home/developer
               e.g., ".env,.mcp.json"
    """
    home_dir = Path("/home/developer")
    files = {}

    path_list = [p.strip() for p in paths.split(",") if p.strip()]

    for rel_path in path_list:
        # Security: prevent path traversal
        clean_path = rel_path.lstrip("/").lstrip(".")
        if ".." in clean_path:
            logger.warning(f"Path traversal attempt blocked: {rel_path}")
            continue

        # Handle paths starting with . (like .env, .mcp.json)
        if rel_path.startswith("."):
            filepath = home_dir / rel_path
        else:
            filepath = home_dir / clean_path

        try:
            if filepath.exists() and filepath.is_file():
                # Verify the resolved path is still under home_dir
                resolved = filepath.resolve()
                if str(resolved).startswith(str(home_dir.resolve())):
                    content = filepath.read_text()
                    files[rel_path] = content
                    logger.debug(f"Read credential file: {rel_path} ({len(content)} bytes)")
                else:
                    logger.warning(f"Path resolved outside home directory: {rel_path}")
        except Exception as e:
            logger.warning(f"Failed to read {rel_path}: {e}")

    return CredentialReadResponse(files=files)


@router.post("/api/credentials/inject")
async def inject_credential_files(request: CredentialInjectRequest):
    """
    Inject credential files directly into workspace.

    This is the simplified credential injection that writes files directly
    without template processing. Used by the new credential system.

    Args:
        request: Contains files dict mapping paths to contents
    """
    home_dir = Path("/home/developer")
    files_written = []

    for rel_path, content in request.files.items():
        # Security: prevent path traversal
        clean_path = rel_path.lstrip("/")
        if ".." in clean_path:
            logger.warning(f"Path traversal attempt blocked: {rel_path}")
            continue

        # Handle paths starting with . (like .env, .mcp.json)
        if clean_path.startswith(".") or rel_path.startswith("."):
            filepath = home_dir / rel_path
        else:
            filepath = home_dir / clean_path

        try:
            # Verify the resolved path is still under home_dir
            resolved = filepath.resolve()
            if not str(resolved).startswith(str(home_dir.resolve())):
                logger.warning(f"Path resolved outside home directory: {rel_path}")
                continue

            # Create parent directories if needed
            filepath.parent.mkdir(parents=True, exist_ok=True)

            # Write the file
            filepath.write_text(content)

            # Set restrictive permissions for credential files (600 = owner read/write only)
            filepath.chmod(0o600)

            files_written.append(rel_path)
            logger.info(f"Wrote credential file: {rel_path} ({len(content)} bytes)")

        except Exception as e:
            logger.error(f"Failed to write {rel_path}: {e}")
            raise HTTPException(status_code=500, detail=f"Failed to write {rel_path}: {str(e)}")

    # Re-inject Trinity MCP if .mcp.json was updated
    if ".mcp.json" in files_written:
        if inject_trinity_mcp_if_configured():
            logger.info("Re-injected Trinity MCP after credential injection")

    # Export updated credentials to environment for this process
    # (helps new subprocesses, though existing ones won't see changes)
    if ".env" in files_written:
        env_file = home_dir / ".env"
        if env_file.exists():
            for line in env_file.read_text().splitlines():
                line = line.strip()
                if line and not line.startswith("#") and "=" in line:
                    key, _, value = line.partition("=")
                    key = key.strip()
                    value = value.strip().strip('"').strip("'")
                    if key:
                        os.environ[key] = value

    return CredentialInjectResponse(
        status="success",
        files_written=files_written
    )
